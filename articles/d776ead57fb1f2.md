---
title: "Golangで並行処理を行うレシピ"
emoji: "🐁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# はじめに

Go を学ぶ以前は Go と言えば並行処理というイメージでしたが、実務で書いていて意外と並行処理を書くことがありませんでした。
並行処理を用いるほど非機能要件が厳しくなかったのもありますが、そもそも Go 自体処理が早いのと並行処理を使う以前にやることがあるという具合でした。（例えば N + 1 になっているところを直すとか、 Pub/Sub 等で非同期処理に切り離すべきとか）
ただ要件がリッチになってきて、ユースケースの処理がどうしても長くなることがあり、並行処理の型を自分に定着させるためにまとめてみました。

# 各並行処理の結果をハンドリングしなくて良い場合

以下のように publish1 と publish2 はお互いに影響を及ぼすものではなく、また呼び出し元でハンドリングする必要がない関数だとします。
こういった場合、 publish1 と publish2 を逐次的に処理する必要はありません。

```go:main.go
package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()

	fmt.Println("do something")

	publish1()
	publish2()

	fmt.Println(time.Since(now))
}

func publish1() {
	time.Sleep(1 * time.Second)
	fmt.Println("Publishing1")
}

func publish2() {
	time.Sleep(1 * time.Second)
	fmt.Println("Publishing2")
}
```

実行すると 2 秒程度かかります。

```
% go run main.go
do something
Publishing1
Publishing2
2.002445459s
```

並行処理を取り入れるとこのようになります。

```go:main.go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	now := time.Now()

	fmt.Println("do something")

    // 2 つ並行処理を行うようカウンターをセット
	waitCount := 2
	var wg sync.WaitGroup
	wg.Add(waitCount)

	go func() {
        // goroutine が終了する時にカウントを減らす
		defer wg.Done()
		publish1()
	}()

	go func() {
		defer wg.Done()
		publish2()
	}()

    // カウントが 0 になるまでブロックする
    // これを書かないとブロックされないので、
    // goroutine が終了する以前にメインプロセスが終わってしまう
	wg.Wait()

	fmt.Println(time.Since(now))
}

func publish1() {
	time.Sleep(1 * time.Second)
	fmt.Println("Publishing1")
}

func publish2() {
	time.Sleep(1 * time.Second)
	fmt.Println("Publishing2")
}
```

実行すると 1 秒程度で、並行処理が上手くいっていますね。

```
% go run main.go
do something
Publishing2
Publishing1
1.001423917s
```

# 各並行処理の結果をハンドリングする場合で、エラーハンドリングはしなくて良い場合

以下のように publish1 と publish2 の結果を受け取って使いたい場合だとします。

```go:main.go
package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()

	fmt.Println("do something")

	result := make([]string, 0, 2)

	result = append(result, publish1())
	result = append(result, publish2())

	fmt.Println(result)

	fmt.Println(time.Since(now))
}

func publish1() string {
	time.Sleep(1 * time.Second)
	return "Publishing1"
}

func publish2() string {
	time.Sleep(1 * time.Second)
	return "Publishing2"
}
```

実行すると 2 秒程度かかります。

```
% go run main.go
do something
[Publishing1 Publishing2]
2.002377375s
```

並行処理を取り入れるとこのようになります。

```go:main.go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	now := time.Now()

	fmt.Println("do something")

	waitCount := 2
	var wg sync.WaitGroup
	wg.Add(waitCount)

	result := make([]string, 2, 2)

	go func() {
		defer wg.Done()
		r := publish1()
		result[0] = r
	}()

	go func() {
		defer wg.Done()
		r := publish2()
		result[1] = r
	}()

	wg.Wait()

	fmt.Println(result)

	fmt.Println(time.Since(now))
}

func publish1() string {
	time.Sleep(1 * time.Second)
	return "Publishing1"
}

func publish2() string {
	time.Sleep(1 * time.Second)
	return "Publishing2"
}
```

実行するとこのようになります。

```
% go run main.go
do something
[Publishing1 Publishing2]
1.001352834s
```

先ほどとほとんど同じですが、ポイントは result のスライスをはじめから len が 2 として生成しているところです。
つまり result は生成時点で空文字が 2 つ入っているスライスです。（空スライスでない）
これは並行処理である以上、 publish1 と publish2 のどちらが先に終わるかは保証されていないので、

```go:main.go
```