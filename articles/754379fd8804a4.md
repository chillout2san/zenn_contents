---
title: "http.ListenAndServe ã£ã¦ä½•ã—ã¦ã„ã‚‹ã®ï¼Ÿ"
emoji: "ğŸ"
type: "tech"
topics: ["Go"]
published: false
---

# ã¯ã˜ã‚ã«

Go ã®å­¦ç¿’ã‚’å§‹ã‚ãŸæ™‚ã«ãƒ“ãƒƒã‚¯ãƒªã—ãŸã®ã¯ã€ã‚µãƒ¼ãƒã‚’ç«‹ã¦ã‚‹ã“ã¨ã®ç°¡å˜ã•ã§ã—ãŸã€‚
ä¾‹ãˆã°ä»¥ä¸‹ã®æ‰‹é †ã§ã‚µãƒ¼ãƒã‚’ç«‹ã¦ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

```go:main.go
package main

import "net/http"

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Hello, World!"))
	})
	http.ListenAndServe(":8080", nil)
}
```

```ã‚¿ãƒ¼ãƒŸãƒŠãƒ«
$ go run main.go
```

```åˆ¥ã‚¿ãƒ¼ãƒŸãƒŠãƒ«
$ curl http://localhost:8080/
Hello, World!
```

ã‚ã¡ã‚ƒãã¡ã‚ƒç°¡å˜ãªåé¢ã€ http.ListenAndServer ã£ã¦ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹æ°—ã«ãªã£ãŸã®ã§ã€€net/http ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’è»½ãã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ã—ã¦ã¿ã¾ã—ãŸã€‚

# çµè«–

Server ã¯ Listener ã‚’å®Ÿè¡Œã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç²å¾—ã—ã¦ã€ Handler ã‚’å®Ÿè¡Œã—ã¦ HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¡Œãªã£ã¦ã„ã‚‹ã€‚
http.ListenAndServe ã¯ã“ã‚Œã‚’æ¥½ã«å®Ÿç¾ã—ã¦ãã‚Œã‚‹é–¢æ•°ã§ã‚ã‚‹ã€‚

ã“ã®çµè«–ã«è¾¿ã‚Šç€ããŸã‚ã«ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã„ãã¾ã™ã€‚

# ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°

### http.ListenAndServe

Server æ§‹é€ ä½“ã«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ handler ã‚’æ¸¡ã—ã¦æ§‹é€ ä½“ã‚’ç”Ÿæˆã—ã€ ListenAndServe ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã‚“ã§ã„ã‚‹ã ã‘ã§ã™ã€‚

```go:net/http/server.go
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

å…ˆã»ã©ã®ä¾‹ã§ã¯ç¬¬äºŒå¼•æ•°ã§ã‚ã‚‹ handler ã«ã¯ nil ã‚’æ¸¡ã—ã¦ã„ã¾ã—ãŸãŒã€ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã‚‹ã¨ã“ã†ã‚ã‚Šã€ nil ã®æ™‚ã«ã¯ http.DefaultServeMux ãŒä½¿ã‚ã‚Œã¾ã™ã€‚

```go:net/http/server.go
type Server struct {
	// ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯çœç•¥

	Handler Handler // handler to invoke, http.DefaultServeMux if nil
}
```

ã¡ãªã¿ã« DefaultServeMux ã® Mux ã¯ multiplexer ã®ã“ã¨ã§ã™ã€‚
å‚è€ƒ: https://wa3.i-3-i.info/word13228.html

DefaultServeMux ã¯ ServeMux ã®ç©ºã®æ§‹é€ ä½“ã®ã“ã¨ã§ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã‚‹ã¨ã“ã†ã‚ã‚Šã¾ã™ã€‚
å¤§é›‘æŠŠã«ç†è§£ã‚’ã™ã‚Œã°ã€ URL ã®ãƒãƒƒãƒãƒ³ã‚°ã‚’è¡Œã†ã‚‚ã®ã¨è€ƒãˆã¦è‰¯ã•ãã†ã§ã™ã€‚

```go:net/http/server.go
// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
// çœç•¥
type ServeMux struct {
	mu       sync.RWMutex
	tree     routingNode
	index    routingIndex
	patterns []*pattern  // TODO(jba): remove if possible
	mux121   serveMux121 // used only when GODEBUG=httpmuxgo121=1
}
```

ãªãŠå†’é ­ã®ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã¯ http.HandleFunc ã§ãƒ‘ã‚¹ã¨ handler ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç´ä»˜ã‘ã‚’è¡Œãªã£ã¦ã„ã¾ã™ãŒã€ä¸­ã‚’èª­ã‚€ã¨ DefaultServeMux ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç™»éŒ²ã‚’è¡Œãªã£ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚
DefaultServeMux ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªå¤‰æ•°ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ç¬¬äºŒå¼•æ•°ã§ nil ã‚’æ¸¡ã—ã¦ã„ãªã„ã®ã«ã‚³ãƒ¼ãƒ«ã—ã¦ã‚‚æ„å‘³ãŒãªã„ã¨æ€ã‚ã‚Œã¾ã™ã€‚

```go:net/http/server.go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if use121 {
		DefaultServeMux.mux121.handleFunc(pattern, handler)
	} else {
		DefaultServeMux.register(pattern, HandlerFunc(handler))
	}
}
```

### server.ListenAndServe

Listener ã‚’ç”Ÿæˆã—ã¦ã€ãã‚Œã‚’ Serve ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã—ã¦ã„ã¾ã™ã€‚
http.ListenAndServe ã¯ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å—ã‘å–ã£ã¦ã„ã¦ã€ãã‚Œã¯ Server æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å…¥ã£ã¦ã„ã¾ã—ãŸãŒã€ Listener ã®ç”Ÿæˆã®ãŸã‚ã ã£ãŸã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

```go:net/http/server.go
func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}
```

### server.Serve

é•·ã„ã®ã§çœç•¥ã—ã¦ã„ã¾ã™ãŒã€é‡è¦ãªã¨ã“ã‚ã¯ã“ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
ãƒ«ãƒ¼ãƒ—ã§ Listener ã® Accept ã‚’å‘¼ã³å‡ºã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºç«‹ã—ã€ã‚´ãƒ«ãƒ¼ãƒãƒ³ã‚’ç«‹ã¡ä¸Šã’ã¦ã„ã¾ã™ã€‚

ã¡ãªã¿ã«srv.newConn ã¯ä½•ã‚’ã—ã¦ã„ã‚‹ã®ã‹åˆ†ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã™ãŒã€ rw ãŒ interface å‹ãªã®ã«å¯¾ã—ã¦ newConn ã®æˆ»ã‚Šå€¤ã¯ struct ã ã£ãŸã®ã§ä½•ã‹ã—ã‚‰å…·ä½“åŒ–ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚
ä»Šå›ã®ã‚³ãƒ¼ãƒ‰ãƒªãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã§ã¯æ°—ã«ã—ãªã„ã“ã¨ã«ã—ã¾ã™ã€‚

```go:net/http/server.go
func (srv *Server) Serve(l net.Listener) error {
	// çœç•¥

	for {
		rw, err := l.Accept()
		// çœç•¥
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew, runHooks) // before Serve can return
		go c.serve(connCtx)
	}
}
```

### c.serve

ã“ã“ã¾ã§ã§ Server ã¯ Listener ã‚’å®Ÿè¡Œã—ã¦ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ç²å¾—ã—ã¦ã„ã‚‹ã¨ã“ã‚ã¾ã§ç¢ºèªã§ãã¾ã—ãŸã€‚
æ®‹ã‚Šã¯ Handler ã‚’å®Ÿè¡Œã—ã¦ HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¡Œãªã£ã¦ã„ã‚‹ç®‡æ‰€ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚
å…ˆã»ã©ãƒ«ãƒ¼ãƒ—ã§ã‚´ãƒ«ãƒ¼ãƒãƒ³ã‚’ç«‹ã¦ã¦ã„ã‚‹ã“ã¨ãŒèª¬æ˜ã•ã‚Œã¦ã„ã¦ã€ http ã¯åŒæ™‚ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŒã‘ãªã„ãŸã‚ã«ã‚´ãƒ«ãƒ¼ãƒãƒ³ã‚’ç«‹ã¦ã¦å¯¾ç­–ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

serverHandler.ServeHTTP ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¦ã„ã¾ã™ãŒã‚‚ã†å°‘ã—ä¸­ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```go:net/http/server.go
func (c *conn) serve(ctx context.Context) {
	// çœç•¥

	for {
		// çœç•¥

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining. We could let them all process
		// in parallel even if their responses need to be serialized.
		// But we're not going to implement HTTP pipelining because it
		// was never deployed in the wild and the answer is HTTP/2.
		inFlightResponse = w
		serverHandler{c.server}.ServeHTTP(w, w.req)
	}
}
```

ãªãŠã“ã‚Œã‹ã‚‰ ServeHTTP ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¤‡æ•°å›å‘¼ã°ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ãŒã€ä»¥ä¸‹ã®ã‚ˆã†ãª interface ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚
ServeHTTP ã¯ãã®åå‰ã®ã¨ãŠã‚Š http ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æ›¸ãè¾¼ã‚€é–¢æ•°ã§ã™ãŒã€è‰²ã€…å·¥ç¨‹ã‚’åˆ†ã‘ã¦è¸ã‚€ãŸã‚è¤‡æ•°å›å‘¼ã°ã‚Œã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚
ResponseWriter ã«å…·ä½“çš„ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æ›¸ãè¾¼ã‚€ã¨ã“ã‚ã¾ã§æ˜ã‚Šé€²ã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```go:net/http/server.go
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

### serverHandler.ServeHTTP

æ³¨ç›®ã—ãŸã„ã®ã¯ srv ã® Handler ãŒ nil ã ã£ãŸå ´åˆã¯ DefaultServeMux ãŒã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚
http.ListenAndServe ã®ç¬¬äºŒå¼•æ•°ãŒ nil ã ã£ãŸã‚‰ã‚ˆã†ã‚„ãã“ã“ã§ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã‚ã‘ã§ã™ã€‚

ãã—ã¦ handler ã® ServeHTTP ãŒã‚³ãƒ¼ãƒ«ã•ã‚Œã¦ãŠã‚Šã€ HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¡Œãªã£ã¦ã„ã‚‹ç®‡æ‰€ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚

```go:net/http/server.go
func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
	handler := sh.srv.Handler
	if handler == nil {
		handler = DefaultServeMux
	}
	if !sh.srv.DisableGeneralOptionsHandler && req.RequestURI == "*" && req.Method == "OPTIONS" {
		handler = globalOptionsHandler{}
	}

	handler.ServeHTTP(rw, req)
}
```
